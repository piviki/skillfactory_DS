# Practice
# Получите сумму чисел, сохранённых в переменных a и b
import numpy as np
a = 6
b = 7
print(np.int64(a)+np.int64(b))
# 13

# Напишите функцию get_chess, которая принимает на вход длину стороны квадрата a и возвращает двумерный массив формы (a, a), заполненный 0 и 1 в шахматном порядке. В левом верхнем углу всегда должен быть ноль
# Remenber: для получения каждого второго элемента используется срез [::2]
def get_chess(a):
    arr = np.zeros((a,a))
    arr[1::2, ::2] = 1 # поменяли нули на 1 в срезах
    arr[::2, 1::2] = 1 # отзеркалили 
    return arr
print(get_chess(1))
# [[0.]]
print(get_chess(4))
# [[0. 1. 0. 1.]
# [1. 0. 1. 0.]
# [0. 1. 0. 1.]
# [1. 0. 1. 0.]]

# вы не хотите хранить в памяти новую версию плейлиста, а просто хотите сохранять тот seed, с которым он был сгенерирован.
# Для этого напишите функцию shuffle_seed(<array>),  которая принимает на вход массив из чисел, генерирует случайное число для seed в диапазоне от 0 до 2**32 - 1 (включительно) и возвращает кортеж: перемешанный с данным seed массив (исходный массив должен оставаться без изменений), а также seed, с которым этот массив был получен
def shuffle_seed(array):
    seed = np.random.randint(2**16) # ValueError: high is out of bounds for int32
    np.random.seed(seed)
    result = np.random.permutation(array)
    return result, seed
array =[1,2,3,4,5]
print(shuffle_seed(array))
# (array([1, 4, 5, 2, 3]), 21929)

# Напишите функцию min_max_dist, которая принимает на вход неограниченное число векторов через запятую. Гарантируется, что все векторы, которые передаются, одинаковой длины
# Функция возвращает минимальное и максимальное расстояние между векторами в виде кортежа
def min_max_dist(*vectors): # * = неограниченное число векторов
    dists = list() # создаем пустой список
    for i in range(len(vectors)):
        for j in range(i+1, len(vectors)):
            dists.append(np.linalg.norm(vectors[i]-vectors[j])) 
    return (min(dists), max(dists))
vec1 = np.array([1,2,3])
vec2 = np.array([4,5,6])
vec3 = np.array([7,8,9])
print(min_max_dist(vec1, vec2, vec3))
# (5.196152422706632, 10.392304845413264)

# Напишите функцию any_normal, которая принимает на вход неограниченное число векторов через запятую. Гарантируется, что все векторы, которые передаются, одинаковой длины.
# Функция возвращает True, если есть хотя бы одна пара перпендикулярных векторов. Иначе возвращает False
def any_normal(*vectors):
    for i in range(len(vectors)):
        for j in range(i+1, len(vectors)):
            if np.dot(vectors[i],vectors[j]) == 0: # создаем условие, что есть одна пара перпендикулярных векторов
                return True
            return False
vec1 = np.array([2, 1])
vec2 = np.array([-1, 2])
vec3 = np.array([3,4])
print(any_normal(vec1, vec2, vec3))
# True

# Напишите функцию get_loto(num), генерирующую трёхмерный массив случайных целых чисел от 1 до 100 (включительно). Это поля для игры в лото
# Трёхмерный массив должен состоять из таблиц чисел формы 5х5, то есть итоговая форма — (num, 5, 5).
# Функция возвращает полученный массив
def get_loto(num):
    loto = np.random.randint(1,101, size = (num, 5,5))
    return loto
print(get_loto(2))
#[[[27 94 57 50 40]
# [22 91  6 77 37]
# [28 56 86 65 31]
# [71 49 52 41 85]
# [88 90 83 97 29]]

# [[11 69  4 53 94]
#  [ 3 82 25 95  2]
#  [34 79 21 22 81]
#  [37 40 30 79 49]
#  [78 58 28 48 93]]]

# Напишите функцию get_unique_loto(num). Она так же, как и функция в задании 10.10, генерирует num полей для игры в лото, однако теперь на каждом поле 5х5 числа не могут повторяться.
# Функция также должна возвращать массив формы num x 5 x 5.
def get_unique_loto(num):
    



    